/* tslint:disable */
/* eslint-disable */
/**
 * One-API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CancelOtp200Response } from '../models';
// @ts-ignore
import type { CancelOtp404Response } from '../models';
// @ts-ignore
import type { CancelOtp422Response } from '../models';
// @ts-ignore
import type { OtpChannel } from '../models';
// @ts-ignore
import type { OtpList200Response } from '../models';
// @ts-ignore
import type { OtpStatus } from '../models';
// @ts-ignore
import type { ResendOtp200Response } from '../models';
// @ts-ignore
import type { ResendOtp404Response } from '../models';
// @ts-ignore
import type { ResendOtp422Response } from '../models';
// @ts-ignore
import type { SendOtp201Response } from '../models';
// @ts-ignore
import type { SendOtp422Response } from '../models';
// @ts-ignore
import type { SendOtpRequest } from '../models';
// @ts-ignore
import type { SortWay } from '../models';
// @ts-ignore
import type { StatusOtp200Response } from '../models';
// @ts-ignore
import type { StatusOtp404Response } from '../models';
// @ts-ignore
import type { TooManyRequestsResponse } from '../models';
// @ts-ignore
import type { VerifyOtp200Response } from '../models';
// @ts-ignore
import type { VerifyOtp404Response } from '../models';
// @ts-ignore
import type { VerifyOtp422Response } from '../models';
// @ts-ignore
import type { VerifyOtpRequest } from '../models';
/**
 * TwoFAOTPApi - axios parameter creator
 * @export
 */
export const TwoFAOTPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Used to cancel the authentication process. In this case, authentication must be in the Pending status.
         * @summary Cancel the authentication session
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOtp: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelOtp', 'id', id)
            const localVarPath = `/api/2fa/authentications/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ExternalAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use to get a list of authentications for a period.
         * @summary List of authentication sessions
         * @param {string} filterFrom Period start date (date and time when the authentication session was created) in ISO 8601 format.
         * @param {string} filterTo End date of the period (date and time when the authentication was created) in ISO 8601 format.
         * @param {number} [pageOffset] 
         * @param {number} [pageLimit] 
         * @param {Set<string>} [filterIds] Authentication ID. The maximum number is 3.
         * @param {OtpStatus} [filterStatus] 
         * @param {OtpChannel} [filterChannel] 
         * @param {string} [filterRecipient] 
         * @param {string} [filterCountryCode] 
         * @param {SortWay} [way] 
         * @param {OtpListSortEnum} [sort] Sort by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpList: async (filterFrom: string, filterTo: string, pageOffset?: number, pageLimit?: number, filterIds?: Set<string>, filterStatus?: OtpStatus, filterChannel?: OtpChannel, filterRecipient?: string, filterCountryCode?: string, way?: SortWay, sort?: OtpListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterFrom' is not null or undefined
            assertParamExists('otpList', 'filterFrom', filterFrom)
            // verify required parameter 'filterTo' is not null or undefined
            assertParamExists('otpList', 'filterTo', filterTo)
            const localVarPath = `/api/2fa/authentications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ExternalAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageOffset !== undefined) {
                localVarQueryParameter['page[offset]'] = pageOffset;
            }

            if (pageLimit !== undefined) {
                localVarQueryParameter['page[limit]'] = pageLimit;
            }

            if (filterFrom !== undefined) {
                localVarQueryParameter['filter[from]'] = (filterFrom as any instanceof Date) ?
                    (filterFrom as any).toISOString().substring(0,10) :
                    filterFrom;
            }

            if (filterTo !== undefined) {
                localVarQueryParameter['filter[to]'] = (filterTo as any instanceof Date) ?
                    (filterTo as any).toISOString().substring(0,10) :
                    filterTo;
            }

            if (filterIds) {
                localVarQueryParameter['filter[ids]'] = Array.from(filterIds);
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterChannel !== undefined) {
                localVarQueryParameter['filter[channel]'] = filterChannel;
            }

            if (filterRecipient !== undefined) {
                localVarQueryParameter['filter[recipient]'] = filterRecipient;
            }

            if (filterCountryCode !== undefined) {
                localVarQueryParameter['filter[country_code]'] = filterCountryCode;
            }

            if (way !== undefined) {
                localVarQueryParameter['way'] = way;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * sed to resend the one-time password to the recipient: a new one-time password is generated and sent in the message, and the previous one becomes invalid. When resending, already saved data is used to generate the OTP from the request [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp).  *This API call is available only if the current authentication is not completed before its expiration date (the authentication validity period is specified in each TwoFA API response).*
         * @summary Resend the one-time code
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendOtp: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resendOtp', 'id', id)
            const localVarPath = `/api/2fa/authentications/otp/{id}/resend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ExternalAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API call is used to generate and send a one-time password to a user in an SMS or Viber message. **Please note:** authentication of recipients who are in the SMS or Viber stop list in your contact book is not possible using the corresponding method. (That is, if the recipient is in the SMS stop list, then when requesting authentication using the SMS method, the one-time password will not be sent, and you will receive an error in response).
         * @summary Send One-time password
         * @param {SendOtpRequest} sendOtpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOtp: async (sendOtpRequest: SendOtpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendOtpRequest' is not null or undefined
            assertParamExists('sendOtp', 'sendOtpRequest', sendOtpRequest)
            const localVarPath = `/api/2fa/authentications/otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ExternalAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendOtpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use to get information about the current authentication status by specifying its identifier.
         * @summary Check authentication status
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusOtp: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('statusOtp', 'id', id)
            const localVarPath = `/api/2fa/authentications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ExternalAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API call is used to verify that the one-time password you received from the user matches the one sent by BSG
         * @summary Check one-time Code
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {VerifyOtpRequest} verifyOtpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOtp: async (id: string, verifyOtpRequest: VerifyOtpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('verifyOtp', 'id', id)
            // verify required parameter 'verifyOtpRequest' is not null or undefined
            assertParamExists('verifyOtp', 'verifyOtpRequest', verifyOtpRequest)
            const localVarPath = `/api/2fa/authentications/otp/{id}/verify`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ExternalAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyOtpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TwoFAOTPApi - functional programming interface
 * @export
 */
export const TwoFAOTPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TwoFAOTPApiAxiosParamCreator(configuration)
    return {
        /**
         * Used to cancel the authentication process. In this case, authentication must be in the Pending status.
         * @summary Cancel the authentication session
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOtp(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelOtp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOtp(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwoFAOTPApi.cancelOtp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use to get a list of authentications for a period.
         * @summary List of authentication sessions
         * @param {string} filterFrom Period start date (date and time when the authentication session was created) in ISO 8601 format.
         * @param {string} filterTo End date of the period (date and time when the authentication was created) in ISO 8601 format.
         * @param {number} [pageOffset] 
         * @param {number} [pageLimit] 
         * @param {Set<string>} [filterIds] Authentication ID. The maximum number is 3.
         * @param {OtpStatus} [filterStatus] 
         * @param {OtpChannel} [filterChannel] 
         * @param {string} [filterRecipient] 
         * @param {string} [filterCountryCode] 
         * @param {SortWay} [way] 
         * @param {OtpListSortEnum} [sort] Sort by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async otpList(filterFrom: string, filterTo: string, pageOffset?: number, pageLimit?: number, filterIds?: Set<string>, filterStatus?: OtpStatus, filterChannel?: OtpChannel, filterRecipient?: string, filterCountryCode?: string, way?: SortWay, sort?: OtpListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OtpList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.otpList(filterFrom, filterTo, pageOffset, pageLimit, filterIds, filterStatus, filterChannel, filterRecipient, filterCountryCode, way, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwoFAOTPApi.otpList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * sed to resend the one-time password to the recipient: a new one-time password is generated and sent in the message, and the previous one becomes invalid. When resending, already saved data is used to generate the OTP from the request [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp).  *This API call is available only if the current authentication is not completed before its expiration date (the authentication validity period is specified in each TwoFA API response).*
         * @summary Resend the one-time code
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendOtp(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResendOtp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendOtp(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwoFAOTPApi.resendOtp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API call is used to generate and send a one-time password to a user in an SMS or Viber message. **Please note:** authentication of recipients who are in the SMS or Viber stop list in your contact book is not possible using the corresponding method. (That is, if the recipient is in the SMS stop list, then when requesting authentication using the SMS method, the one-time password will not be sent, and you will receive an error in response).
         * @summary Send One-time password
         * @param {SendOtpRequest} sendOtpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendOtp(sendOtpRequest: SendOtpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendOtp201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendOtp(sendOtpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwoFAOTPApi.sendOtp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use to get information about the current authentication status by specifying its identifier.
         * @summary Check authentication status
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusOtp(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusOtp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusOtp(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwoFAOTPApi.statusOtp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The API call is used to verify that the one-time password you received from the user matches the one sent by BSG
         * @summary Check one-time Code
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {VerifyOtpRequest} verifyOtpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyOtp(id: string, verifyOtpRequest: VerifyOtpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyOtp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyOtp(id, verifyOtpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwoFAOTPApi.verifyOtp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TwoFAOTPApi - factory interface
 * @export
 */
export const TwoFAOTPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TwoFAOTPApiFp(configuration)
    return {
        /**
         * Used to cancel the authentication process. In this case, authentication must be in the Pending status.
         * @summary Cancel the authentication session
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOtp(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CancelOtp200Response> {
            return localVarFp.cancelOtp(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Use to get a list of authentications for a period.
         * @summary List of authentication sessions
         * @param {string} filterFrom Period start date (date and time when the authentication session was created) in ISO 8601 format.
         * @param {string} filterTo End date of the period (date and time when the authentication was created) in ISO 8601 format.
         * @param {number} [pageOffset] 
         * @param {number} [pageLimit] 
         * @param {Set<string>} [filterIds] Authentication ID. The maximum number is 3.
         * @param {OtpStatus} [filterStatus] 
         * @param {OtpChannel} [filterChannel] 
         * @param {string} [filterRecipient] 
         * @param {string} [filterCountryCode] 
         * @param {SortWay} [way] 
         * @param {OtpListSortEnum} [sort] Sort by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpList(filterFrom: string, filterTo: string, pageOffset?: number, pageLimit?: number, filterIds?: Set<string>, filterStatus?: OtpStatus, filterChannel?: OtpChannel, filterRecipient?: string, filterCountryCode?: string, way?: SortWay, sort?: OtpListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<OtpList200Response> {
            return localVarFp.otpList(filterFrom, filterTo, pageOffset, pageLimit, filterIds, filterStatus, filterChannel, filterRecipient, filterCountryCode, way, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * sed to resend the one-time password to the recipient: a new one-time password is generated and sent in the message, and the previous one becomes invalid. When resending, already saved data is used to generate the OTP from the request [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp).  *This API call is available only if the current authentication is not completed before its expiration date (the authentication validity period is specified in each TwoFA API response).*
         * @summary Resend the one-time code
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendOtp(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ResendOtp200Response> {
            return localVarFp.resendOtp(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This API call is used to generate and send a one-time password to a user in an SMS or Viber message. **Please note:** authentication of recipients who are in the SMS or Viber stop list in your contact book is not possible using the corresponding method. (That is, if the recipient is in the SMS stop list, then when requesting authentication using the SMS method, the one-time password will not be sent, and you will receive an error in response).
         * @summary Send One-time password
         * @param {SendOtpRequest} sendOtpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOtp(sendOtpRequest: SendOtpRequest, options?: RawAxiosRequestConfig): AxiosPromise<SendOtp201Response> {
            return localVarFp.sendOtp(sendOtpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use to get information about the current authentication status by specifying its identifier.
         * @summary Check authentication status
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusOtp(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusOtp200Response> {
            return localVarFp.statusOtp(id, options).then((request) => request(axios, basePath));
        },
        /**
         * The API call is used to verify that the one-time password you received from the user matches the one sent by BSG
         * @summary Check one-time Code
         * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
         * @param {VerifyOtpRequest} verifyOtpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOtp(id: string, verifyOtpRequest: VerifyOtpRequest, options?: RawAxiosRequestConfig): AxiosPromise<VerifyOtp200Response> {
            return localVarFp.verifyOtp(id, verifyOtpRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TwoFAOTPApi - interface
 * @export
 * @interface TwoFAOTPApi
 */
export interface TwoFAOTPApiInterface {
    /**
     * Used to cancel the authentication process. In this case, authentication must be in the Pending status.
     * @summary Cancel the authentication session
     * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApiInterface
     */
    cancelOtp(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CancelOtp200Response>;

    /**
     * Use to get a list of authentications for a period.
     * @summary List of authentication sessions
     * @param {string} filterFrom Period start date (date and time when the authentication session was created) in ISO 8601 format.
     * @param {string} filterTo End date of the period (date and time when the authentication was created) in ISO 8601 format.
     * @param {number} [pageOffset] 
     * @param {number} [pageLimit] 
     * @param {Set<string>} [filterIds] Authentication ID. The maximum number is 3.
     * @param {OtpStatus} [filterStatus] 
     * @param {OtpChannel} [filterChannel] 
     * @param {string} [filterRecipient] 
     * @param {string} [filterCountryCode] 
     * @param {SortWay} [way] 
     * @param {OtpListSortEnum} [sort] Sort by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApiInterface
     */
    otpList(filterFrom: string, filterTo: string, pageOffset?: number, pageLimit?: number, filterIds?: Set<string>, filterStatus?: OtpStatus, filterChannel?: OtpChannel, filterRecipient?: string, filterCountryCode?: string, way?: SortWay, sort?: OtpListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<OtpList200Response>;

    /**
     * sed to resend the one-time password to the recipient: a new one-time password is generated and sent in the message, and the previous one becomes invalid. When resending, already saved data is used to generate the OTP from the request [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp).  *This API call is available only if the current authentication is not completed before its expiration date (the authentication validity period is specified in each TwoFA API response).*
     * @summary Resend the one-time code
     * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApiInterface
     */
    resendOtp(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ResendOtp200Response>;

    /**
     * This API call is used to generate and send a one-time password to a user in an SMS or Viber message. **Please note:** authentication of recipients who are in the SMS or Viber stop list in your contact book is not possible using the corresponding method. (That is, if the recipient is in the SMS stop list, then when requesting authentication using the SMS method, the one-time password will not be sent, and you will receive an error in response).
     * @summary Send One-time password
     * @param {SendOtpRequest} sendOtpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApiInterface
     */
    sendOtp(sendOtpRequest: SendOtpRequest, options?: RawAxiosRequestConfig): AxiosPromise<SendOtp201Response>;

    /**
     * Use to get information about the current authentication status by specifying its identifier.
     * @summary Check authentication status
     * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApiInterface
     */
    statusOtp(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusOtp200Response>;

    /**
     * The API call is used to verify that the one-time password you received from the user matches the one sent by BSG
     * @summary Check one-time Code
     * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
     * @param {VerifyOtpRequest} verifyOtpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApiInterface
     */
    verifyOtp(id: string, verifyOtpRequest: VerifyOtpRequest, options?: RawAxiosRequestConfig): AxiosPromise<VerifyOtp200Response>;

}

/**
 * TwoFAOTPApi - object-oriented interface
 * @export
 * @class TwoFAOTPApi
 * @extends {BaseAPI}
 */
export class TwoFAOTPApi extends BaseAPI implements TwoFAOTPApiInterface {
    /**
     * Used to cancel the authentication process. In this case, authentication must be in the Pending status.
     * @summary Cancel the authentication session
     * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApi
     */
    public cancelOtp(id: string, options?: RawAxiosRequestConfig) {
        return TwoFAOTPApiFp(this.configuration).cancelOtp(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use to get a list of authentications for a period.
     * @summary List of authentication sessions
     * @param {string} filterFrom Period start date (date and time when the authentication session was created) in ISO 8601 format.
     * @param {string} filterTo End date of the period (date and time when the authentication was created) in ISO 8601 format.
     * @param {number} [pageOffset] 
     * @param {number} [pageLimit] 
     * @param {Set<string>} [filterIds] Authentication ID. The maximum number is 3.
     * @param {OtpStatus} [filterStatus] 
     * @param {OtpChannel} [filterChannel] 
     * @param {string} [filterRecipient] 
     * @param {string} [filterCountryCode] 
     * @param {SortWay} [way] 
     * @param {OtpListSortEnum} [sort] Sort by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApi
     */
    public otpList(filterFrom: string, filterTo: string, pageOffset?: number, pageLimit?: number, filterIds?: Set<string>, filterStatus?: OtpStatus, filterChannel?: OtpChannel, filterRecipient?: string, filterCountryCode?: string, way?: SortWay, sort?: OtpListSortEnum, options?: RawAxiosRequestConfig) {
        return TwoFAOTPApiFp(this.configuration).otpList(filterFrom, filterTo, pageOffset, pageLimit, filterIds, filterStatus, filterChannel, filterRecipient, filterCountryCode, way, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * sed to resend the one-time password to the recipient: a new one-time password is generated and sent in the message, and the previous one becomes invalid. When resending, already saved data is used to generate the OTP from the request [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp).  *This API call is available only if the current authentication is not completed before its expiration date (the authentication validity period is specified in each TwoFA API response).*
     * @summary Resend the one-time code
     * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApi
     */
    public resendOtp(id: string, options?: RawAxiosRequestConfig) {
        return TwoFAOTPApiFp(this.configuration).resendOtp(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API call is used to generate and send a one-time password to a user in an SMS or Viber message. **Please note:** authentication of recipients who are in the SMS or Viber stop list in your contact book is not possible using the corresponding method. (That is, if the recipient is in the SMS stop list, then when requesting authentication using the SMS method, the one-time password will not be sent, and you will receive an error in response).
     * @summary Send One-time password
     * @param {SendOtpRequest} sendOtpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApi
     */
    public sendOtp(sendOtpRequest: SendOtpRequest, options?: RawAxiosRequestConfig) {
        return TwoFAOTPApiFp(this.configuration).sendOtp(sendOtpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use to get information about the current authentication status by specifying its identifier.
     * @summary Check authentication status
     * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApi
     */
    public statusOtp(id: string, options?: RawAxiosRequestConfig) {
        return TwoFAOTPApiFp(this.configuration).statusOtp(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The API call is used to verify that the one-time password you received from the user matches the one sent by BSG
     * @summary Check one-time Code
     * @param {string} id Authentication ID received in response to [POST /api/2fa/authentications/otp](#tag/TwoFA/operation/send_otp) The maximum length is 36 characters.
     * @param {VerifyOtpRequest} verifyOtpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwoFAOTPApi
     */
    public verifyOtp(id: string, verifyOtpRequest: VerifyOtpRequest, options?: RawAxiosRequestConfig) {
        return TwoFAOTPApiFp(this.configuration).verifyOtp(id, verifyOtpRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const OtpListSortEnum = {
    Id: 'id',
    Status: 'status',
    Channel: 'channel',
    Recipient: 'recipient',
    CreatedAt: 'created_at',
    FinishedAt: 'finished_at',
    CountryCode: 'country_code'
} as const;
export type OtpListSortEnum = typeof OtpListSortEnum[keyof typeof OtpListSortEnum];
